# semantic-diff
source code diff tool with semantic comparison

##设计方案
设计方案主要分为两部分实现：
 1. 使用gcc编译源代码文件，生成中间语法树结果，并建立语法树行号与源码的行号之间的关系，然后作函数差异对比，将差异对应回源文件的差异比较中。
 2. 根据差异中变更的行，找到宏的使用情况，然后去头文件中找到定义的宏的位置。

###语法树生成
在生成的语法树中可以找到函数的定义、函数的参数列表、函数体中调用的其他函数等信息；

由于我们主要想获得函数语法差异，调研gcc生成语法树的过程中，找到可以去除其他信息，只保留函数语法信息的gcc命令，gcc -fdump-tree-cfg，可以获得每个函数的控制流图，文件存为cfg。这个图中包含着以gimple命名的标签，如gimple_call是调用其它函数、gimple_return是返回值。

###语法树符号的源代码位置抽取
针对差异分析的要求，找符号与源代码位置的对应关系；

在生成cfg文件的同时，可以再次运行命令gcc -fdump-tree-cfg-lineno，这个指令的意思是可以对已经生成的cfg流文件加入行号信息，对应于源文件中每一行的位置，将这些位置提取出来并以数组形式保存，供最后展示时使用。

###语法树比较
通过语法树的比较，得到两个版本源代码中同一函数的定义差异，重点是函数参数差异；

针对这些gimple的不同做对比，即可获得函数定义的语义对比，对对比的结果进行解析，提取出不同版本增减信息。而函数的参数则可通过之前的源代码差异分析工作获得对比。

###语法树差异与源代码差异的对应关系抽取
基于函数的语法树差异和语法树中符号与源代码的对应关系，得到语法树差异的源代码差异展现；

展示则在源码函数提取出来后，对函数进行修改，即在有语法差异的行的后面以相同的格式插入语法差异的信息，然后在进行源代码差异对比及展示，得到的结果就附加了语义信息。

###宏定义位置的获取调研
 1. 根据资料查询，并没有找到gcc可以回溯查询宏定义的位置。这个问题其实可以具体为两个子问题：
  1. 找到哪行使用了宏
  2. 如何找到这个宏的定义，及其嵌套的宏定义位置

 第一个问题解决的方法可以使用.i与.c文件对比，找到宏展开的行，然后解析出宏，并得到宏的值。可能的问题是.i的格式是否与.c格式相同，可能有其他干扰信息。
 
 第二个问题解决的方法，根据第一种方法找到的宏，使用grep -nR去相关头文件目录去找定义,可能的问题是：可能有多个宏定义相关。如果可以从源程序中调用的头文件中查找，应该是比较精确的。
